// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"context"
	"github.com/byatesrae/coinbase_vwap/internal/coinbase"
	"net/http"
	"sync"
)

// Ensure, that ConnMock does implement coinbase.Conn.
// If this is not the case, regenerate this file with moq.
var _ coinbase.Conn = &ConnMock{}

// ConnMock is a mock implementation of coinbase.Conn.
//
//	func TestSomethingThatUsesConn(t *testing.T) {
//
//		// make and configure a mocked coinbase.Conn
//		mockedConn := &ConnMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ReadJSONFunc: func(v interface{}) error {
//				panic("mock out the ReadJSON method")
//			},
//			WriteJSONFunc: func(v interface{}) error {
//				panic("mock out the WriteJSON method")
//			},
//		}
//
//		// use mockedConn in code that requires coinbase.Conn
//		// and then make assertions.
//
//	}
type ConnMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ReadJSONFunc mocks the ReadJSON method.
	ReadJSONFunc func(v interface{}) error

	// WriteJSONFunc mocks the WriteJSON method.
	WriteJSONFunc func(v interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ReadJSON holds details about calls to the ReadJSON method.
		ReadJSON []struct {
			// V is the v argument value.
			V interface{}
		}
		// WriteJSON holds details about calls to the WriteJSON method.
		WriteJSON []struct {
			// V is the v argument value.
			V interface{}
		}
	}
	lockClose     sync.RWMutex
	lockReadJSON  sync.RWMutex
	lockWriteJSON sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ConnMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ConnMock.CloseFunc: method is nil but Conn.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedConn.CloseCalls())
func (mock *ConnMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// ReadJSON calls ReadJSONFunc.
func (mock *ConnMock) ReadJSON(v interface{}) error {
	if mock.ReadJSONFunc == nil {
		panic("ConnMock.ReadJSONFunc: method is nil but Conn.ReadJSON was just called")
	}
	callInfo := struct {
		V interface{}
	}{
		V: v,
	}
	mock.lockReadJSON.Lock()
	mock.calls.ReadJSON = append(mock.calls.ReadJSON, callInfo)
	mock.lockReadJSON.Unlock()
	return mock.ReadJSONFunc(v)
}

// ReadJSONCalls gets all the calls that were made to ReadJSON.
// Check the length with:
//
//	len(mockedConn.ReadJSONCalls())
func (mock *ConnMock) ReadJSONCalls() []struct {
	V interface{}
} {
	var calls []struct {
		V interface{}
	}
	mock.lockReadJSON.RLock()
	calls = mock.calls.ReadJSON
	mock.lockReadJSON.RUnlock()
	return calls
}

// WriteJSON calls WriteJSONFunc.
func (mock *ConnMock) WriteJSON(v interface{}) error {
	if mock.WriteJSONFunc == nil {
		panic("ConnMock.WriteJSONFunc: method is nil but Conn.WriteJSON was just called")
	}
	callInfo := struct {
		V interface{}
	}{
		V: v,
	}
	mock.lockWriteJSON.Lock()
	mock.calls.WriteJSON = append(mock.calls.WriteJSON, callInfo)
	mock.lockWriteJSON.Unlock()
	return mock.WriteJSONFunc(v)
}

// WriteJSONCalls gets all the calls that were made to WriteJSON.
// Check the length with:
//
//	len(mockedConn.WriteJSONCalls())
func (mock *ConnMock) WriteJSONCalls() []struct {
	V interface{}
} {
	var calls []struct {
		V interface{}
	}
	mock.lockWriteJSON.RLock()
	calls = mock.calls.WriteJSON
	mock.lockWriteJSON.RUnlock()
	return calls
}

// Ensure, that DialerMock does implement coinbase.Dialer.
// If this is not the case, regenerate this file with moq.
var _ coinbase.Dialer = &DialerMock{}

// DialerMock is a mock implementation of coinbase.Dialer.
//
//	func TestSomethingThatUsesDialer(t *testing.T) {
//
//		// make and configure a mocked coinbase.Dialer
//		mockedDialer := &DialerMock{
//			DialContextFunc: func(ctx context.Context, urlStr string, requestHeader http.Header) (coinbase.Conn, *http.Response, error) {
//				panic("mock out the DialContext method")
//			},
//		}
//
//		// use mockedDialer in code that requires coinbase.Dialer
//		// and then make assertions.
//
//	}
type DialerMock struct {
	// DialContextFunc mocks the DialContext method.
	DialContextFunc func(ctx context.Context, urlStr string, requestHeader http.Header) (coinbase.Conn, *http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// DialContext holds details about calls to the DialContext method.
		DialContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UrlStr is the urlStr argument value.
			UrlStr string
			// RequestHeader is the requestHeader argument value.
			RequestHeader http.Header
		}
	}
	lockDialContext sync.RWMutex
}

// DialContext calls DialContextFunc.
func (mock *DialerMock) DialContext(ctx context.Context, urlStr string, requestHeader http.Header) (coinbase.Conn, *http.Response, error) {
	if mock.DialContextFunc == nil {
		panic("DialerMock.DialContextFunc: method is nil but Dialer.DialContext was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		UrlStr        string
		RequestHeader http.Header
	}{
		Ctx:           ctx,
		UrlStr:        urlStr,
		RequestHeader: requestHeader,
	}
	mock.lockDialContext.Lock()
	mock.calls.DialContext = append(mock.calls.DialContext, callInfo)
	mock.lockDialContext.Unlock()
	return mock.DialContextFunc(ctx, urlStr, requestHeader)
}

// DialContextCalls gets all the calls that were made to DialContext.
// Check the length with:
//
//	len(mockedDialer.DialContextCalls())
func (mock *DialerMock) DialContextCalls() []struct {
	Ctx           context.Context
	UrlStr        string
	RequestHeader http.Header
} {
	var calls []struct {
		Ctx           context.Context
		UrlStr        string
		RequestHeader http.Header
	}
	mock.lockDialContext.RLock()
	calls = mock.calls.DialContext
	mock.lockDialContext.RUnlock()
	return calls
}
